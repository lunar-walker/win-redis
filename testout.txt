cd src && make test
make[1]: Entering directory '/cygdrive/d/code/redis-6.2.2/src'
Cleanup: may take some time... OK
Starting test server at port 21079
[ready]: 29339
[1;37;49mTesting unit/printver[0m
[ready]: 29340
[1;37;49mTesting unit/dump[0m
[ready]: 29341
[1;37;49mTesting unit/auth[0m
[ready]: 29342
[1;37;49mTesting unit/protocol[0m
[ready]: 29343
[1;37;49mTesting unit/keyspace[0m
[ready]: 29344
[1;37;49mTesting unit/scan[0m
[ready]: 29345
[1;37;49mTesting unit/info[0m
[ready]: 29346
[1;37;49mTesting unit/type/string[0m
[ready]: 29347
[1;37;49mTesting unit/type/incr[0m
[ready]: 29349
[1;37;49mTesting unit/type/list[0m
[ready]: 29348
[1;37;49mTesting unit/type/list-2[0m
[ready]: 29350
[1;37;49mTesting unit/type/list-3[0m
[ready]: 29351
[1;37;49mTesting unit/type/set[0m
[ready]: 29352
[1;37;49mTesting unit/type/zset[0m
[ready]: 29353
[1;37;49mTesting unit/type/hash[0m
[ready]: 29354
[1;37;49mTesting unit/type/stream[0m
[[0;32;49mok[0m]: DUMP / RESTORE are able to serialize / unserialize a simple key
Testing Redis version 6.2.2 (00000000)
[[0;32;49mok[0m]: RESTORE can set an arbitrary expire to the materialized key
[[0;32;49mok[0m]: RESTORE can set an expire that overflows a 32 bit integer
[[0;32;49mok[0m]: RESTORE can set an absolute expire
[[0;32;49mok[0m]: RESTORE with ABSTTL in the past
[[0;32;49mok[0m]: RESTORE can set LRU
[[0;32;49mok[0m]: RESTORE can set LFU
[[0;32;49mok[0m]: RESTORE returns an error of the key already exists
[[0;32;49mok[0m]: RESTORE can overwrite an existing key with REPLACE
[[0;32;49mok[0m]: RESTORE can detect a syntax error for unrecongized options
[[0;32;49mok[0m]: DUMP of non existing key returns nil
[[0;32;49mok[0m]: AUTH fails if there is no password configured server side
[[0;32;49mok[0m]: Handle an empty query
[[0;32;49mok[0m]: DEL against a single item
[[0;32;49mok[0m]: Negative multibulk length
[[0;32;49mok[0m]: Vararg DEL
[[0;32;49mok[0m]: Out of range multibulk length
[[0;32;49mok[0m]: KEYS with pattern
[[0;32;49mok[0m]: Wrong multibulk payload header
[[0;32;49mok[0m]: Negative multibulk payload length
[[0;32;49mok[0m]: KEYS to get all keys
[[0;32;49mok[0m]: Out of range multibulk payload length
[[0;32;49mok[0m]: DBSIZE
[[0;32;49mok[0m]: SET and GET an item
[[0;32;49mok[0m]: Non-number multibulk payload length
[[0;32;49mok[0m]: DEL all keys
[[0;32;49mok[0m]: SET and GET an empty item
[[0;32;49mok[0m]: Multi bulk request not followed by bulk arguments
[[0;32;49mok[0m]: Generic wrong number of args
[[0;32;49mok[0m]: Unbalanced number of quotes
[[0;32;49mok[0m]: INCR against non existing key
[[0;32;49mok[0m]: INCR against key created by incr itself
[[0;32;49mok[0m]: INCR against key originally set with SET
[[0;32;49mok[0m]: INCR over 32bit value
[[0;32;49mok[0m]: INCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCR fails against key with spaces (left)
[[0;32;49mok[0m]: INCR fails against key with spaces (right)
[[0;32;49mok[0m]: INCR fails against key with spaces (both)
[[0;32;49mok[0m]: INCR fails against a key holding a list
[[0;32;49mok[0m]: DECRBY over 32bit value with over 32bit increment, negative res
[[0;31;49merr[0m]: Protocol desync regression test #1 in tests/unit/protocol.tcl
Expected '*Protocol error*' to equal or match ''
[[0;32;49mok[0m]: SCAN basic
[[0;32;49mok[0m]: INCR uses shared objects in the 0-9999 range
[[0;32;49mok[0m]: INCR can modify objects in-place
[[0;32;49mok[0m]: INCRBYFLOAT against non existing key
[[0;32;49mok[0m]: Very big payload in GET/SET
[[0;32;49mok[0m]: INCRBYFLOAT against key originally set with SET
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: INCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (left)
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (right)
[[0;32;49mok[0m]: INCRBYFLOAT fails against key with spaces (both)
[[0;32;49mok[0m]: INCRBYFLOAT fails against a key holding a list
[[0;32;49mok[0m]: LPOS basic usage
[[0;32;49mok[0m]: LPOS RANK (positive and negative rank) option
[[0;32;49mok[0m]: INCRBYFLOAT does not allow NaN or Infinity
[[0;32;49mok[0m]: INCRBYFLOAT decrement
[[0;32;49mok[0m]: Explicit regression for a list bug
[[0;32;49mok[0m]: Check encoding - ziplist
[[0;32;49mok[0m]: string to double with null terminator
[[0;32;49mok[0m]: LPOS COUNT option
[[0;32;49mok[0m]: Regression for quicklist #3343 bug
[[0;32;49mok[0m]: SCAN COUNT
[[0;32;49mok[0m]: LPOS COUNT + RANK option
[[0;32;49mok[0m]: No negative zero
[[0;32;49mok[0m]: ZSET basic ZADD and score update - ziplist
[[0;32;49mok[0m]: LPOS non existing key
[[0;32;49mok[0m]: LPOS no match
[[0;32;49mok[0m]: SCAN MATCH
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - ziplist
[[0;31;49merr[0m]: Protocol desync regression test #2 in tests/unit/protocol.tcl
Expected '*Protocol error*' to equal or match ''
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY - ziplist
[[0;32;49mok[0m]: LPOS MAXLEN
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair - ziplist
[[0;32;49mok[0m]: LPOS when RANK is greater than matches
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - regular set
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist
[[0;32;49mok[0m]: ZADD XX option without key - ziplist
[[0;32;49mok[0m]: ZADD XX existing key - ziplist
[[0;32;49mok[0m]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list
[[0;32;49mok[0m]: SADD, SCARD, SISMEMBER, SMISMEMBER, SMEMBERS basics - intset
[[0;32;49mok[0m]: SMISMEMBER against non set
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added - ziplist
[[0;32;49mok[0m]: XADD can add entries into a stream that XRANGE can fetch
[[0;32;49mok[0m]: SMISMEMBER non existing key
[[0;32;49mok[0m]: XADD IDs are incremental
[[0;32;49mok[0m]: ZADD XX updates existing elements score - ziplist
[[0;32;49mok[0m]: SMISMEMBER requires one or more members
[[0;32;49mok[0m]: XADD IDs are incremental when ms is the same as well
[[0;32;49mok[0m]: XADD IDs correctly report an error when overflowing
[[0;32;49mok[0m]: SADD against non set
[[0;32;49mok[0m]: ZADD GT updates existing elements when new scores are greater - ziplist
[[0;32;49mok[0m]: ZADD LT updates existing elements when new scores are lower - ziplist
[[0;32;49mok[0m]: SADD a non-integer against an intset
[[0;32;49mok[0m]: SADD an integer larger than 64 bits
[[0;32;49mok[0m]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - ziplist
[[0;32;49mok[0m]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - ziplist
[[0;32;49mok[0m]: ZADD XX and NX are not compatible - ziplist
[[0;32;49mok[0m]: ZADD NX with non existing key - ziplist
[[0;31;49merr[0m]: Protocol desync regression test #3 in tests/unit/protocol.tcl
Expected '*Protocol error*' to equal or match ''
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones - ziplist
[[0;32;49mok[0m]: ZADD GT and NX are not compatible - ziplist
[[0;32;49mok[0m]: ZADD LT and NX are not compatible - ziplist
[[0;32;49mok[0m]: SCAN TYPE
[[0;32;49mok[0m]: SSCAN with encoding intset
[[0;32;49mok[0m]: ZADD LT and GT are not compatible - ziplist
[[0;32;49mok[0m]: R/LPOP against empty list
[[0;32;49mok[0m]: SSCAN with encoding hashtable
[[0;32;49mok[0m]: ZADD INCR LT/GT replies with nill if score not updated - ziplist
[[0;32;49mok[0m]: R/LPOP with the optional count argument
[[0;32;49mok[0m]: HSCAN with encoding ziplist
[[0;32;49mok[0m]: ZADD INCR LT/GT with inf - ziplist
[[0;32;49mok[0m]: Variadic RPUSH/LPUSH
[[0;32;49mok[0m]: DEL a list
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - linkedlist
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair - ziplist
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - linkedlist
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - linkedlist
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error - ziplist
[[0;32;49mok[0m]: ZADD - Variadic version base case - $encoding
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items - $encoding
[[0;32;49mok[0m]: BRPOPLPUSH - linkedlist
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err - $encoding
[[0;32;49mok[0m]: BLMOVE left left - linkedlist
[[0;32;49mok[0m]: HSCAN with encoding hashtable
[[0;32;49mok[0m]: ZSCAN with encoding ziplist
[[0;32;49mok[0m]: BLMOVE left right - linkedlist
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg - $encoding
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding
[[0;32;49mok[0m]: BLMOVE right left - linkedlist
[[0;32;49mok[0m]: SADD overflows the maximum allowed integers in an intset
[[0;32;49mok[0m]: Variadic SADD
[[0;32;49mok[0m]: ZCARD basics - ziplist
[[0;32;49mok[0m]: BLMOVE right right - linkedlist
[[0;32;49mok[0m]: HSET/HLEN - Small hash creation
[[0;32;49mok[0m]: BLPOP, BRPOP: single existing list - ziplist
[[0;32;49mok[0m]: Is the small hash encoded with a ziplist?
[[0;32;49mok[0m]: ZREM removes key after last element is removed - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: multiple existing lists - ziplist
[[0;32;49mok[0m]: ZREM variadic version - ziplist
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion - ziplist
[[0;32;49mok[0m]: BLPOP, BRPOP: second list has an entry - ziplist
[[0;32;49mok[0m]: ZRANGE basics - ziplist
[[0;32;49mok[0m]: ZREVRANGE basics - ziplist
[[0;32;49mok[0m]: HRANDFIELD - ziplist
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - ziplist
[[0;32;49mok[0m]: BRPOPLPUSH - ziplist
[[0;32;49mok[0m]: BLMOVE left left - ziplist
[[0;32;49mok[0m]: HRANDFIELD - hashtable
[[0;32;49mok[0m]: ZSCAN with encoding skiplist
[[0;32;49mok[0m]: BLMOVE left right - ziplist
[[0;32;49mok[0m]: BLMOVE right left - ziplist
[[0;32;49mok[0m]: BLMOVE right right - ziplist
[[0;32;49mok[0m]: ZRANK - after deletion - ziplist
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL should not awake blocked client
[[0;32;49mok[0m]: XADD with MAXLEN option
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - ziplist
[[0;32;49mok[0m]: SCAN guarantees check under write load
[[0;32;49mok[0m]: HRANDFIELD with RESP3
[[0;32;49mok[0m]: SSCAN with integer encoded object (issue #1345)
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - ziplist
[[0;32;49mok[0m]: HRANDFIELD count of 0 is handled correctly
[[0;32;49mok[0m]: ZINCRBY return value - ziplist
[[0;32;49mok[0m]: SSCAN with PATTERN
[[0;32;49mok[0m]: HRANDFIELD with <count> against non existing key
[[0;32;49mok[0m]: HSCAN with PATTERN
[1/64 [0;33;49mdone[0m]: unit/printver (6 seconds)
[1;37;49mTesting unit/type/stream-cgroups[0m
[[0;32;49mok[0m]: ZSCAN with PATTERN
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - ziplist
[[0;32;49mok[0m]: BLPOP, LPUSH + DEL + SET should not awake blocked client
[[0;32;49mok[0m]: BLPOP with same key multiple times should work (issue #801)
[[0;32;49mok[0m]: MULTI/EXEC is isolated from the point of view of BLPOP
[[0;32;49mok[0m]: BLPOP with variadic LPUSH
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES - ziplist
[[0;32;49mok[0m]: DEL against expired key
[[0;32;49mok[0m]: EXISTS
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT - ziplist
[[0;32;49mok[0m]: Zero length value in key. SET/GET/EXISTS
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES - ziplist
[[0;32;49mok[0m]: Commands pipelining
[[0;32;49mok[0m]: Non existing command
[[0;32;49mok[0m]: RENAME basic usage
[[0;32;49mok[0m]: RENAME source key should no longer exist
[[0;32;49mok[0m]: RENAME against already existing key
[[0;32;49mok[0m]: RENAMENX basic usage
[[0;32;49mok[0m]: RENAMENX against already existing key
[[0;32;49mok[0m]: RENAMENX against already existing key (2)
[[0;32;49mok[0m]: RENAME against non existing source key
[[0;32;49mok[0m]: RENAME where source and dest key are the same (existing)
[[0;32;49mok[0m]: RENAMENX where source and dest key are the same (existing)
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max - ziplist
[[0;32;49mok[0m]: RENAME where source and dest key are the same (non existing)
[[0;32;49mok[0m]: RENAME with volatile key, should move the TTL as well
[[0;32;49mok[0m]: RENAME with volatile key, should not inherit TTL of target key
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - ziplist
[[0;32;49mok[0m]: DEL all keys again (DB 0)
[[0;32;49mok[0m]: ZLEXCOUNT advanced - ziplist
[[0;32;49mok[0m]: DEL all keys again (DB 1)
[[0;32;49mok[0m]: COPY basic usage for string
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT - ziplist
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers - ziplist
[[0;32;49mok[0m]: COPY for string does not replace an existing key without REPLACE option
[[0;32;49mok[0m]: COPY for string can replace an existing key with REPLACE option
[[0;32;49mok[0m]: COPY for string ensures that copied data is independent of copying data
[[0;32;49mok[0m]: COPY for string does not copy data to no-integer DB
[[0;32;49mok[0m]: COPY can copy key expire metadata as well
[[0;32;49mok[0m]: ZSCAN scores: regression test for issue #2175
[[0;32;49mok[0m]: COPY does not create an expire if it does not exist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics - ziplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max - ziplist
[[0;32;49mok[0m]: COPY basic usage for list
[[0;32;49mok[0m]: COPY basic usage for intset set
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist
[[0;32;49mok[0m]: COPY basic usage for hashtable set
[[0;32;49mok[0m]: COPY basic usage for ziplist sorted set
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF against non-existing key - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with empty set - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with integer members - ziplist
[[0;32;49mok[0m]: HRANDFIELD with <count> - hashtable
[[0;32;49mok[0m]: ZUNIONSTORE with weights - ziplist
[[0;32;49mok[0m]: XADD with MAXLEN option and the '=' argument
[[0;32;49mok[0m]: ZUNION with weights - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - ziplist
[[0;32;49mok[0m]: COPY basic usage for skiplist sorted set
[[0;32;49mok[0m]: COPY basic usage for ziplist hash
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: BRPOPLPUSH with zero timeout should block indefinitely
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZINTERSTORE basics - ziplist
[[0;32;49mok[0m]: BLMOVE left left with zero timeout should block indefinitely
[[0;32;49mok[0m]: ZINTER basics - ziplist
[[0;32;49mok[0m]: ZINTER RESP3 - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with weights - ziplist
[[0;32;49mok[0m]: BLMOVE left right with zero timeout should block indefinitely
[[0;32;49mok[0m]: COPY basic usage for hashtable hash
[[0;32;49mok[0m]: ZINTER with weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - ziplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - ziplist
[[0;32;49mok[0m]: BLMOVE right left with zero timeout should block indefinitely
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights - ziplist
[[0;32;49mok[0m]: BLMOVE right right with zero timeout should block indefinitely
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - ziplist
[[0;32;49mok[0m]: Set encoding after DEBUG RELOAD
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights - ziplist
[[0;32;49mok[0m]: ZDIFFSTORE basics - ziplist
[[0;32;49mok[0m]: BLMOVE (left, left) with a client BLPOPing the target list
[[0;32;49mok[0m]: SREM basics - regular set
[[0;32;49mok[0m]: ZDIFF basics - ziplist
[[0;32;49mok[0m]: SREM basics - intset
[[0;32;49mok[0m]: SREM with multiple arguments
[[0;32;49mok[0m]: ZDIFFSTORE with a regular set - ziplist
[[0;32;49mok[0m]: SREM variadic version with more args needed to destroy the key
[[0;32;49mok[0m]: ZDIFF subtracting set from itself - ziplist
[[0;32;49mok[0m]: BLMOVE (left, right) with a client BLPOPing the target list
[[0;32;49mok[0m]: ZDIFF algorithm 1 - ziplist
[[0;32;49mok[0m]: ZDIFF algorithm 2 - ziplist
[[0;32;49mok[0m]: HRANDFIELD with <count> - ziplist
[[0;32;49mok[0m]: BLMOVE (right, left) with a client BLPOPing the target list
[[0;32;49mok[0m]: BLMOVE (right, right) with a client BLPOPing the target list
[[0;32;49mok[0m]: BRPOPLPUSH with wrong source type
[[0;32;49mok[0m]: XADD with MAXLEN option and the '~' argument
[[0;32;49mok[0m]: XADD with NOMKSTREAM option
[[0;32;49mok[0m]: BRPOPLPUSH with wrong destination type
[[0;32;49mok[0m]: BRPOPLPUSH maintains order of elements after failure
[[0;32;49mok[0m]: Generated sets must be encoded as hashtable
[[0;32;49mok[0m]: BRPOPLPUSH with multiple blocked clients
[[0;32;49mok[0m]: SINTER with two sets - hashtable
[[0;32;49mok[0m]: SINTERSTORE with two sets - hashtable
[[0;32;49mok[0m]: Linked LMOVEs
[[0;32;49mok[0m]: Circular BRPOPLPUSH
[[0;32;49mok[0m]: Self-referential BRPOPLPUSH
[[0;32;49mok[0m]: BRPOPLPUSH inside a transaction
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable
[[0;32;49mok[0m]: PUSH resulting from BRPOPLPUSH affect WATCH
[[0;31;49merr[0m]: BRPOPLPUSH does not affect WATCH while still blocked in tests/unit/type/list.tcl
Expected 'somevalue' to equal or match ''
[[0;32;49mok[0m]: SUNION with two sets - hashtable
[[0;32;49mok[0m]: SUNIONSTORE with two sets - hashtable
[[0;32;49mok[0m]: SINTER against three sets - hashtable
[[0;32;49mok[0m]: SINTERSTORE with three sets - hashtable
[[0;32;49mok[0m]: COPY basic usage for stream
[[0;32;49mok[0m]: SUNION with non existing keys - hashtable
[[0;32;49mok[0m]: SDIFF with two sets - hashtable
[[0;32;49mok[0m]: COPY basic usage for stream-cgroups
[[0;32;49mok[0m]: SDIFF with three sets - hashtable
[[0;32;49mok[0m]: MOVE basic usage
[[0;32;49mok[0m]: MOVE against key existing in the target DB
[[0;32;49mok[0m]: SDIFFSTORE with three sets - hashtable
[[0;32;49mok[0m]: MOVE against non-integer DB (#1428)
[[0;32;49mok[0m]: MOVE can move key expire metadata as well
[[0;32;49mok[0m]: MOVE does not create an expire if it does not exist
[[0;32;49mok[0m]: SET/GET keys in different DBs
[[0;32;49mok[0m]: RANDOMKEY
[[0;32;49mok[0m]: RANDOMKEY against empty DB
[[0;32;49mok[0m]: RANDOMKEY regression 1
[[0;32;49mok[0m]: KEYS * two times with long key, Github issue #1208
[[0;32;49mok[0m]: HSET/HLEN - Big hash creation
[[0;32;49mok[0m]: Is the big hash encoded with an hash table?
[[0;32;49mok[0m]: HGET against the small hash
[[0;32;49mok[0m]: Generated sets must be encoded as intset
[[0;32;49mok[0m]: SINTER with two sets - intset
[[0;32;49mok[0m]: SINTERSTORE with two sets - intset
[[0;32;49mok[0m]: XADD with MINID option
[[0;32;49mok[0m]: XTRIM with MINID option
[[0;32;49mok[0m]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset
[[0;32;49mok[0m]: SUNION with two sets - intset
[[0;32;49mok[0m]: SUNIONSTORE with two sets - intset
[[0;32;49mok[0m]: SINTER against three sets - intset
[[0;32;49mok[0m]: SINTERSTORE with three sets - intset
[[0;32;49mok[0m]: SUNION with non existing keys - intset
[[0;32;49mok[0m]: SDIFF with two sets - intset
[[0;32;49mok[0m]: SDIFF with three sets - intset
[[0;32;49mok[0m]: SDIFFSTORE with three sets - intset
[[0;32;49mok[0m]: SDIFF with first set empty
[[0;32;49mok[0m]: SDIFF with same set two times
[[0;32;49mok[0m]: HGET against the big hash
[[0;32;49mok[0m]: HGET against non existing key
[[0;32;49mok[0m]: HSET in update and insert mode
[[0;32;49mok[0m]: HSETNX target key missing - small hash
[[0;32;49mok[0m]: HSETNX target key exists - small hash
[[0;32;49mok[0m]: HSETNX target key missing - big hash
[[0;32;49mok[0m]: HSETNX target key exists - big hash
[[0;32;49mok[0m]: HMSET wrong number of args
[[0;32;49mok[0m]: HMSET - small hash
[[0;32;49mok[0m]: HMSET - big hash
[[0;32;49mok[0m]: HMGET against non existing key and fields
[[0;32;49mok[0m]: HMGET against wrong type
[[0;32;49mok[0m]: HMGET - small hash
[[0;32;49mok[0m]: HMGET - big hash
[[0;32;49mok[0m]: HKEYS - small hash
[[0;32;49mok[0m]: HKEYS - big hash
[[0;32;49mok[0m]: HVALS - small hash
[[0;32;49mok[0m]: HVALS - big hash
[[0;32;49mok[0m]: HGETALL - small hash
[[0;32;49mok[0m]: HGETALL - big hash
[[0;32;49mok[0m]: HDEL and return value
[[0;32;49mok[0m]: HDEL - more than a single value
[[0;32;49mok[0m]: BRPOPLPUSH timeout
[[0;32;49mok[0m]: BLPOP when new key is moved into place
[[0;32;49mok[0m]: HDEL - hash becomes empty before deleting all specified fields
[[0;32;49mok[0m]: HEXISTS
[[0;32;49mok[0m]: BLPOP when result key is created by SORT..STORE
[[0;32;49mok[0m]: Is a ziplist encoded Hash promoted on big payload?
[[0;32;49mok[0m]: BLPOP: with single empty list argument
[[0;32;49mok[0m]: HINCRBY against non existing database key
[[0;32;49mok[0m]: HINCRBY against non existing hash key
[[0;32;49mok[0m]: HINCRBY against hash key created by hincrby itself
[[0;32;49mok[0m]: BLPOP: with negative timeout
[[0;32;49mok[0m]: HINCRBY against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBY over 32bit value
[[0;32;49mok[0m]: BLPOP: with non-integer timeout
[[0;32;49mok[0m]: HINCRBY over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBY fails against hash value with spaces (right)
[[0;32;49mok[0m]: HINCRBY can detect overflows
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing database key
[[0;32;49mok[0m]: HINCRBYFLOAT against non existing hash key
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key created by hincrby itself
[2/64 [0;33;49mdone[0m]: unit/type/incr (8 seconds)
[1;37;49mTesting unit/sort[0m
[[0;32;49mok[0m]: HINCRBYFLOAT against hash key originally set with HSET
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value
[[0;32;49mok[0m]: HINCRBYFLOAT over 32bit value with over 32bit increment
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (left)
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value with spaces (right)
[[0;32;49mok[0m]: HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle
[[0;32;49mok[0m]: HSTRLEN against the small hash
[[0;32;49mok[0m]: Very big payload random access
[[0;32;49mok[0m]: HSTRLEN against the big hash
[[0;32;49mok[0m]: HSTRLEN against non existing field
[[0;32;49mok[0m]: HSTRLEN corner cases
[[0;32;49mok[0m]: Hash ziplist regression test for large keys
[[0;32;49mok[0m]: Hash fuzzing #1 - 10 fields
[[0;32;49mok[0m]: Hash fuzzing #2 - 10 fields
[3/64 [0;33;49mdone[0m]: unit/keyspace (9 seconds)
[1;37;49mTesting unit/expire[0m
[[0;32;49mok[0m]: BLPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BLPOP: second argument is not a list
[[0;32;49mok[0m]: BLPOP: timeout
[[0;32;49mok[0m]: BLPOP: arguments are empty
[[0;32;49mok[0m]: BRPOP: with single empty list argument
[[0;32;49mok[0m]: BRPOP: with negative timeout
[[0;32;49mok[0m]: BRPOP: with non-integer timeout
[[0;32;49mok[0m]: BRPOP: with zero timeout should block indefinitely
[[0;32;49mok[0m]: BRPOP: second argument is not a list
[[0;32;49mok[0m]: Stress tester for #3343-alike bugs
[[0;32;49mok[0m]: BRPOP: timeout
[[0;32;49mok[0m]: BRPOP: arguments are empty
[[0;32;49mok[0m]: BLPOP inside a transaction
[[0;32;49mok[0m]: LPUSHX, RPUSHX - generic
[[0;32;49mok[0m]: LPUSHX, RPUSHX - linkedlist
[[0;32;49mok[0m]: LINSERT - linkedlist
[[0;32;49mok[0m]: LPUSHX, RPUSHX - ziplist
[[0;32;49mok[0m]: LINSERT - ziplist
[[0;32;49mok[0m]: LINSERT raise error on bad syntax
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: XADD mass insertion and XLEN
[[0;32;49mok[0m]: XADD with ID 0-0
[[0;32;49mok[0m]: XRANGE COUNT works as expected
[[0;32;49mok[0m]: XREVRANGE COUNT works as expected
[[0;32;49mok[0m]: LINDEX random access - quicklist
[[0;32;49mok[0m]: errorstats: failed call authentication error
[[0;32;49mok[0m]: errorstats: failed call within MULTI/EXEC
[[0;32;49mok[0m]: errorstats: failed call within LUA
[[0;32;49mok[0m]: errorstats: failed call NOSCRIPT error
[[0;32;49mok[0m]: errorstats: failed call NOGROUP error
[[0;32;49mok[0m]: errorstats: rejected call unknown command
[[0;32;49mok[0m]: errorstats: rejected call within MULTI/EXEC
[[0;32;49mok[0m]: errorstats: rejected call due to wrong arity
[[0;32;49mok[0m]: errorstats: rejected call by OOM error
[[0;32;49mok[0m]: errorstats: rejected call by authorization error
[[0;32;49mok[0m]: XRANGE can be used to iterate the whole stream
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: LINDEX consistency test - quicklist
[[0;32;49mok[0m]: ziplist implementation: value encoding and backlink
[[0;32;49mok[0m]: LINDEX random access - quicklist
[[0;32;49mok[0m]: Hash fuzzing #1 - 512 fields
[[0;32;49mok[0m]: XGROUP CREATE: creation and duplicate group name detection
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation fails without MKSTREAM
[[0;32;49mok[0m]: XGROUP CREATE: automatic stream creation works with MKSTREAM
[[0;32;49mok[0m]: XREADGROUP will return only new elements
[[0;32;49mok[0m]: XREADGROUP can read the history of the elements we own
[[0;32;49mok[0m]: XPENDING is able to return pending items
[[0;32;49mok[0m]: XREVRANGE returns the reverse of XRANGE
[[0;32;49mok[0m]: XRANGE exclusive ranges
[[0;32;49mok[0m]: XPENDING can return single consumer items
[[0;32;49mok[0m]: XPENDING only group
[[0;32;49mok[0m]: XPENDING with IDLE
[[0;32;49mok[0m]: XPENDING with exclusive range intervals works as expected
[[0;32;49mok[0m]: XACK is able to remove items from the consumer/group PEL
[[0;32;49mok[0m]: XACK can't remove the same item multiple times
[[0;32;49mok[0m]: XACK is able to accept multiple arguments
[[0;32;49mok[0m]: XACK should fail if got at least one invalid ID
[[0;32;49mok[0m]: PEL NACK reassignment after XGROUP SETID event
[[0;32;49mok[0m]: XREADGROUP will not report data on empty history. Bug #5577
[[0;32;49mok[0m]: XREADGROUP history reporting of deleted entries. Bug #5570
[[0;32;49mok[0m]: XREAD with non empty stream
[[0;32;49mok[0m]: Non blocking XREAD with empty streams
[[0;32;49mok[0m]: XREAD with non empty second stream
[[0;32;49mok[0m]: Blocking XREADGROUP will not reply with an empty array
[[0;32;49mok[0m]: XGROUP DESTROY should unblock XREADGROUP with -NOGROUP
[[0;32;49mok[0m]: RENAME can unblock XREADGROUP with data
[[0;32;49mok[0m]: RENAME can unblock XREADGROUP with -NOGROUP
[[0;32;49mok[0m]: Check if list is still ok after a DEBUG RELOAD - quicklist
[[0;32;49mok[0m]: XCLAIM can claim PEL items from another consumer
[[0;32;49mok[0m]: LLEN against non-list value error
[[0;32;49mok[0m]: LLEN against non existing key
[[0;32;49mok[0m]: LINDEX against non-list value error
[[0;32;49mok[0m]: LINDEX against non existing key
[[0;32;49mok[0m]: LPUSH against non-list value error
[[0;32;49mok[0m]: RPUSH against non-list value error
[[0;32;49mok[0m]: RPOPLPUSH base case - linkedlist
[[0;32;49mok[0m]: LMOVE left left base case - linkedlist
[[0;32;49mok[0m]: LMOVE left right base case - linkedlist
[[0;32;49mok[0m]: LMOVE right left base case - linkedlist
[[0;32;49mok[0m]: LMOVE right right base case - linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: AUTH fails when a wrong password is given
[[0;32;49mok[0m]: LMOVE left left with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE left right with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE right left with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: LMOVE right right with the same list as src and dst - linkedlist
[[0;32;49mok[0m]: Arbitrary command gives an error when AUTH is required
[[0;32;49mok[0m]: AUTH succeeds when the right password is given
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: Once AUTH succeeded we can actually send commands to the server
[[0;32;49mok[0m]: LMOVE left left with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left right with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right left with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right right with linkedlist source and existing target linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left left with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left right with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right left with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right right with linkedlist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH base case - ziplist
[[0;32;49mok[0m]: Old Ziplist: SORT BY key
[[0;32;49mok[0m]: Old Ziplist: SORT BY key with limit
[[0;32;49mok[0m]: Old Ziplist: SORT BY hash field
[[0;32;49mok[0m]: LMOVE left left base case - ziplist
[[0;32;49mok[0m]: LMOVE left right base case - ziplist
[[0;32;49mok[0m]: LMOVE right left base case - ziplist
[[0;32;49mok[0m]: LMOVE right right base case - ziplist
[[0;32;49mok[0m]: XCLAIM without JUSTID increments delivery count
[[0;32;49mok[0m]: RPOPLPUSH with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE left left with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE left right with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE right left with the same list as src and dst - ziplist
[[0;32;49mok[0m]: LMOVE right right with the same list as src and dst - ziplist
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left left with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE left right with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right left with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: LMOVE right right with ziplist source and existing target linkedlist
[[0;32;49mok[0m]: RPOPLPUSH with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left left with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE left right with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right left with ziplist source and existing target ziplist
[[0;32;49mok[0m]: LMOVE right right with ziplist source and existing target ziplist
[[0;32;49mok[0m]: RPOPLPUSH against non existing key
[[0;32;49mok[0m]: RPOPLPUSH against non list src key
[[0;32;49mok[0m]: RPOPLPUSH against non list dst key
[[0;32;49mok[0m]: RPOPLPUSH against non existing src key
[[0;32;49mok[0m]: Basic LPOP/RPOP - linkedlist
[[0;32;49mok[0m]: Basic LPOP/RPOP - ziplist
[[0;32;49mok[0m]: LPOP/RPOP against non list value
[[0;32;49mok[0m]: XCLAIM same consumer
[[0;32;49mok[0m]: MIGRATE is caching connections
[[0;32;49mok[0m]: Regression for a crash with blocking ops and pipelining
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: EXPIRE - set timeouts multiple times
[[0;32;49mok[0m]: EXPIRE - It should be still possible to read 'x'
[[0;32;49mok[0m]: XAUTOCLAIM can claim PEL items from another consumer
[[0;32;49mok[0m]: Mass RPOP/LPOP - quicklist
[[0;32;49mok[0m]: LRANGE basics - linkedlist
[[0;32;49mok[0m]: LRANGE inverted indexes - linkedlist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - linkedlist
[[0;32;49mok[0m]: LRANGE out of range negative end index - linkedlist
[[0;32;49mok[0m]: LRANGE basics - ziplist
[[0;32;49mok[0m]: LRANGE inverted indexes - ziplist
[[0;32;49mok[0m]: LRANGE out of range indexes including the full list - ziplist
[[0;32;49mok[0m]: LRANGE out of range negative end index - ziplist
[[0;32;49mok[0m]: LRANGE against non existing key
[[0;32;49mok[0m]: LRANGE with start > end yields an empty array for backward compatibility
[[0;32;49mok[0m]: SET 10000 numeric keys and access all them in reverse order
[[0;32;49mok[0m]: DBSIZE should be 10000 now
[[0;32;49mok[0m]: SETNX target key missing
[[0;32;49mok[0m]: LTRIM basics - linkedlist
[[0;32;49mok[0m]: SETNX target key exists
[[0;32;49mok[0m]: SETNX against not-expired volatile key
[[0;32;49mok[0m]: LTRIM out of range negative end index - linkedlist
[[0;32;49mok[0m]: XAUTOCLAIM as an iterator
[[0;32;49mok[0m]: XAUTOCLAIM COUNT must be > 0
[[0;32;49mok[0m]: XINFO FULL output
[[0;32;49mok[0m]: XGROUP CREATECONSUMER: create consumer if does not exist
[[0;32;49mok[0m]: XGROUP CREATECONSUMER: group must exist
[[0;32;49mok[0m]: LTRIM basics - ziplist
[[0;32;49mok[0m]: LTRIM out of range negative end index - ziplist
[[0;32;49mok[0m]: LSET - linkedlist
[[0;32;49mok[0m]: LSET out of range index - linkedlist
[[0;32;49mok[0m]: LSET - ziplist
[[0;32;49mok[0m]: LSET out of range index - ziplist
[[0;32;49mok[0m]: LSET against non existing key
[[0;32;49mok[0m]: LSET against non list value
[[0;32;49mok[0m]: LREM remove all the occurrences - linkedlist
[[0;32;49mok[0m]: LREM remove the first occurrence - linkedlist
[[0;32;49mok[0m]: Old Linked list: SORT BY key
[[0;32;49mok[0m]: Old Linked list: SORT BY key with limit
[[0;32;49mok[0m]: LREM remove non existing element - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count - linkedlist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - linkedlist
[[0;32;49mok[0m]: Old Linked list: SORT BY hash field
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - linkedlist
[[0;32;49mok[0m]: LREM remove all the occurrences - ziplist
[[0;32;49mok[0m]: LREM remove the first occurrence - ziplist
[[0;32;49mok[0m]: LREM remove non existing element - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count - ziplist
[[0;32;49mok[0m]: LREM starting from tail with negative count (2) - ziplist
[[0;32;49mok[0m]: LREM deleting objects that may be int encoded - ziplist
[[0;32;49mok[0m]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds
[[0;32;49mok[0m]: EXPIRE - After 2.1 seconds the key should no longer be here
[[0;32;49mok[0m]: EXPIRE - write on expire should work
[[0;32;49mok[0m]: EXPIREAT - Check for EXPIRE alike behavior
[[0;32;49mok[0m]: SETEX - Set + Expire combo operation. Check for TTL
[[0;32;49mok[0m]: SETEX - Check value
[[0;32;49mok[0m]: SETEX - Overwrite old key
[[0;32;49mok[0m]: Hash fuzzing #2 - 512 fields
[[0;32;49mok[0m]: client unblock tests
[[0;32;49mok[0m]: List ziplist of various encodings
[[0;32;49mok[0m]: List ziplist of various encodings - sanitize dump
[[0;32;49mok[0m]: SETEX - Wait for the key to expire
[[0;32;49mok[0m]: SETEX - Wrong time parameter
[[0;32;49mok[0m]: PERSIST can undo an EXPIRE
[[0;32;49mok[0m]: PERSIST returns 0 against non existing or non volatile keys
[4/64 [0;33;49mdone[0m]: unit/protocol (21 seconds)
[1;37;49mTesting unit/other[0m
[5/64 [0;33;49mdone[0m]: unit/type/list (21 seconds)
[1;37;49mTesting unit/multi[0m
[[0;32;49mok[0m]: EXPIRE precision is now the millisecond
[[0;32;49mok[0m]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires
[[0;32;49mok[0m]: TTL returns time to live in seconds
[[0;32;49mok[0m]: PTTL returns time to live in milliseconds
[[0;32;49mok[0m]: TTL / PTTL return -1 if key has no expire
[[0;32;49mok[0m]: TTL / PTTL return -2 if key does not exit
[[0;32;49mok[0m]: Stress test the hash ziplist -> hashtable encoding conversion
[[0;32;49mok[0m]: Test HINCRBYFLOAT for correct float representation (issue #2846)
[[0;32;49mok[0m]: Hash ziplist of various encodings
[[0;32;49mok[0m]: Hash ziplist of various encodings - sanitize dump
[[0;32;49mok[0m]: SDIFF fuzzing
[[0;32;49mok[0m]: SINTER against non-set should throw error
[[0;32;49mok[0m]: SUNION against non-set should throw error
[[0;32;49mok[0m]: SINTER should handle non existing key as empty
[[0;32;49mok[0m]: SINTER with same integer elements but different encoding
[[0;32;49mok[0m]: SINTERSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: SUNIONSTORE against non existing keys should delete dstkey
[[0;32;49mok[0m]: XREADGROUP with NOACK creates consumer
[[0;32;49mok[0m]: ZDIFF fuzzing - ziplist
[[0;32;49mok[0m]: SPOP basics - hashtable
[[0;32;49mok[0m]: Basic ZPOP with a single key - ziplist
[[0;32;49mok[0m]: SPOP with <count>=1 - hashtable
[[0;32;49mok[0m]: ZPOP with count - ziplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - ziplist
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - ziplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - ziplist
[[0;32;49mok[0m]: SRANDMEMBER - hashtable
[[0;32;49mok[0m]: SPOP basics - intset
[[0;32;49mok[0m]: SPOP with <count>=1 - intset
[[0;32;49mok[0m]: Check encoding - skiplist
[[0;32;49mok[0m]: ZSET basic ZADD and score update - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZADD - skiplist
[[0;32;49mok[0m]: ZSET element can't be set to NaN with ZINCRBY - skiplist
[[0;32;49mok[0m]: ZADD with options syntax error with incomplete pair - skiplist
[[0;32;49mok[0m]: SRANDMEMBER - intset
[[0;32;49mok[0m]: ZADD XX option without key - skiplist
[[0;32;49mok[0m]: ZADD XX existing key - skiplist
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: ZADD XX returns the number of elements actually added - skiplist
[[0;32;49mok[0m]: ZADD XX updates existing elements score - skiplist
[[0;32;49mok[0m]: SPOP with <count>
[[0;32;49mok[0m]: ZADD GT updates existing elements when new scores are greater - skiplist
[[0;32;49mok[0m]: SPOP using integers, testing Knuth's and Floyd's algorithm
[[0;32;49mok[0m]: ZADD LT updates existing elements when new scores are lower - skiplist
[[0;32;49mok[0m]: SPOP using integers with Knuth's algorithm
[[0;32;49mok[0m]: ZADD GT XX updates existing elements when new scores are greater and skips new elements - skiplist
[[0;32;49mok[0m]: SPOP new implementation: code path #1
[[0;32;49mok[0m]: SPOP new implementation: code path #2
[[0;32;49mok[0m]: ZADD LT XX updates existing elements when new scores are lower and skips new elements - skiplist
[[0;32;49mok[0m]: ZADD XX and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD NX with non existing key - skiplist
[[0;32;49mok[0m]: ZADD NX only add new elements without updating old ones - skiplist
[[0;32;49mok[0m]: SPOP new implementation: code path #3
[[0;32;49mok[0m]: ZADD GT and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD LT and NX are not compatible - skiplist
[[0;32;49mok[0m]: ZADD LT and GT are not compatible - skiplist
[[0;32;49mok[0m]: ZADD INCR LT/GT replies with nill if score not updated - skiplist
[[0;32;49mok[0m]: SRANDMEMBER with <count> against non existing key
[[0;32;49mok[0m]: ZADD INCR LT/GT with inf - skiplist
[[0;32;49mok[0m]: ZADD INCR works like ZINCRBY - skiplist
[[0;32;49mok[0m]: SRANDMEMBER with <count> - hashtable
[[0;32;49mok[0m]: SETNX against expired volatile key
[[0;32;49mok[0m]: ZADD INCR works with a single score-elemenet pair - skiplist
[[0;32;49mok[0m]: GETEX EX option
[[0;32;49mok[0m]: ZADD CH option changes return value to all changed elements - skiplist
[[0;32;49mok[0m]: GETEX PX option
[[0;32;49mok[0m]: ZINCRBY calls leading to NaN result in error - skiplist
[[0;32;49mok[0m]: GETEX EXAT option
[[0;32;49mok[0m]: ZADD - Variadic version base case - $encoding
[[0;32;49mok[0m]: GETEX PXAT option
[[0;32;49mok[0m]: ZADD - Return value is the number of actually added items - $encoding
[[0;32;49mok[0m]: GETEX PERSIST option
[[0;32;49mok[0m]: ZADD - Variadic version does not add nothing on single parsing err - $encoding
[[0;32;49mok[0m]: SRANDMEMBER with <count> - intset
[[0;32;49mok[0m]: ZADD - Variadic version will raise error on missing arg - $encoding
[[0;32;49mok[0m]: GETEX no option
[[0;32;49mok[0m]: ZINCRBY does not work variadic even if shares ZADD implementation - $encoding
[[0;32;49mok[0m]: GETEX syntax errors
[[0;32;49mok[0m]: GETEX no arguments
[[0;32;49mok[0m]: ZCARD basics - skiplist
[[0;32;49mok[0m]: GETDEL command
[[0;32;49mok[0m]: ZREM removes key after last element is removed - skiplist
[[0;32;49mok[0m]: ZREM variadic version - skiplist
[[0;32;49mok[0m]: ZREM variadic version -- remove elements after key deletion - skiplist
[[0;32;49mok[0m]: ZRANGE basics - skiplist
[[0;32;49mok[0m]: ZREVRANGE basics - skiplist
[[0;32;49mok[0m]: ZRANK/ZREVRANK basics - skiplist
[[0;32;49mok[0m]: ZRANK - after deletion - skiplist
[[0;32;49mok[0m]: ZINCRBY - can create a new sorted set - skiplist
[[0;32;49mok[0m]: ZINCRBY - increment and decrement - skiplist
[[0;32;49mok[0m]: ZINCRBY return value - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with WITHSCORES - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with LIMIT and WITHSCORES - skiplist
[[0;32;49mok[0m]: ZRANGEBYSCORE with non-value min or max - skiplist
[[0;32;49mok[0m]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics - skiplist
[6/64 [0;33;49mdone[0m]: unit/type/hash (24 seconds)
[1;37;49mTesting unit/quit[0m
[[0;32;49mok[0m]: ZLEXCOUNT advanced - skiplist
[[0;32;49mok[0m]: ZRANGEBYSLEX with LIMIT - skiplist
[[0;32;49mok[0m]: SRANDMEMBER histogram distribution - hashtable
[[0;32;49mok[0m]: Redis should actively expire keys incrementally
[[0;32;49mok[0m]: GETDEL propagate as DEL command to replica
[[0;32;49mok[0m]: ZRANGEBYLEX with invalid lex range specifiers - skiplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE basics - skiplist
[[0;32;49mok[0m]: ZREMRANGEBYSCORE with non-value min or max - skiplist
[[0;32;49mok[0m]: Unsafe command names are sanitized in INFO output
[[0;32;49mok[0m]: ZREMRANGEBYRANK basics - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF against non-existing key - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with empty set - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with empty set - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE basics - skiplist
[[0;32;49mok[0m]: ZUNION/ZINTER/ZDIFF with integer members - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with weights - skiplist
[[0;32;49mok[0m]: ZUNION with weights - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: GETEX without argument does not propagate to replica
[[0;32;49mok[0m]: SRANDMEMBER histogram distribution - intset
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: SMOVE basics - from regular set to intset
[[0;32;49mok[0m]: MGET
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: MGET against non existing key
[[0;32;49mok[0m]: ZUNIONSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: SMOVE basics - from intset to regular set
[[0;32;49mok[0m]: MGET against non-string key
[[0;32;49mok[0m]: ZUNION/ZINTER with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: SMOVE non existing key
[[0;32;49mok[0m]: GETSET (set new value)
[[0;32;49mok[0m]: ZINTERSTORE basics - skiplist
[[0;32;49mok[0m]: ZINTER basics - skiplist
[[0;32;49mok[0m]: GETSET (replace old value)
[[0;32;49mok[0m]: SMOVE non existing src set
[[0;32;49mok[0m]: MSET base case
[[0;32;49mok[0m]: SMOVE from regular set to non existing destination set
[[0;32;49mok[0m]: ZINTER RESP3 - skiplist
[[0;32;49mok[0m]: MSET wrong number of args
[[0;32;49mok[0m]: SMOVE from intset to non existing destination set
[[0;32;49mok[0m]: ZINTERSTORE with weights - skiplist
[[0;32;49mok[0m]: SMOVE wrong src key type
[[0;32;49mok[0m]: MSETNX with already existent key
[[0;32;49mok[0m]: ZINTER with weights - skiplist
[[0;32;49mok[0m]: SMOVE wrong dst key type
[[0;32;49mok[0m]: MSETNX with not existing keys
[[0;32;49mok[0m]: ZINTERSTORE with a regular set and weights - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MIN - skiplist
[[0;32;49mok[0m]: STRLEN against non-existing key
[[0;32;49mok[0m]: SMOVE with identical source and destination
[[0;32;49mok[0m]: STRLEN against integer-encoded value
[[0;32;49mok[0m]: ZINTERSTORE with AGGREGATE MAX - skiplist
[[0;32;49mok[0m]: STRLEN against plain string
[[0;32;49mok[0m]: ZUNIONSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: ZUNIONSTORE with NaN weights - skiplist
[[0;32;49mok[0m]: SETBIT against non-existing key
[[0;32;49mok[0m]: ZINTERSTORE with +inf/-inf scores - skiplist
[[0;32;49mok[0m]: ZINTERSTORE with NaN weights - skiplist
[[0;32;49mok[0m]: SETBIT against string-encoded key
[[0;32;49mok[0m]: SETBIT against integer-encoded key
[[0;32;49mok[0m]: ZDIFFSTORE basics - skiplist
[[0;32;49mok[0m]: SETBIT against key with wrong type
[[0;32;49mok[0m]: ZDIFF basics - skiplist
[[0;32;49mok[0m]: SETBIT with out of range bit offset
[[0;32;49mok[0m]: ZDIFFSTORE with a regular set - skiplist
[[0;32;49mok[0m]: SETBIT with non-bit argument
[[0;32;49mok[0m]: ZDIFF subtracting set from itself - skiplist
[[0;32;49mok[0m]: ZDIFF algorithm 1 - skiplist
[[0;32;49mok[0m]: ZDIFF algorithm 2 - skiplist
[[0;32;49mok[0m]: Consumer without PEL is present in AOF after AOFRW
[[0;32;49mok[0m]: Redis should lazy expire keys
[[0;32;49mok[0m]: AUTH fails when binary password is wrong
[[0;32;49mok[0m]: AUTH succeeds when binary password is correct
[[0;32;49mok[0m]: EXPIRE should not resurrect keys (issue #1026)
[[0;32;49mok[0m]: 5 keys in, 5 keys out
[[0;32;49mok[0m]: EXPIRE with empty string as TTL should report an error
[[0;32;49mok[0m]: SET with EX with big integer should report an error
[[0;32;49mok[0m]: SET with EX with smallest integer should report an error
[[0;32;49mok[0m]: GETEX with big integer should report an error
[[0;32;49mok[0m]: GETEX with smallest integer should report an error
[[0;32;49mok[0m]: EXPIRE with big integer overflows when converted to milliseconds
[[0;32;49mok[0m]: PEXPIRE with big integer overflow when basetime is added
[[0;32;49mok[0m]: EXPIRE with big negative integer
[[0;32;49mok[0m]: PEXPIREAT with big integer works
[[0;32;49mok[0m]: PEXPIREAT with big negative integer works
[[0;32;49mok[0m]: SETBIT fuzzing
[[0;32;49mok[0m]: GETBIT against non-existing key
[[0;32;49mok[0m]: GETBIT against string-encoded key
[[0;32;49mok[0m]: SAVE - make sure there are all the types as values
[[0;32;49mok[0m]: GETBIT against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against non-existing key
[[0;32;49mok[0m]: SETRANGE against string-encoded key
[[0;32;49mok[0m]: SETRANGE against integer-encoded key
[[0;32;49mok[0m]: SETRANGE against key with wrong type
[[0;32;49mok[0m]: SETRANGE with out of range offset
[[0;32;49mok[0m]: GETRANGE against non-existing key
[[0;32;49mok[0m]: GETRANGE against string value
[[0;32;49mok[0m]: GETRANGE against integer-encoded value
[7/64 [0;33;49mdone[0m]: unit/info (27 seconds)
[1;37;49mTesting unit/aofrw[0m
[[0;32;49mok[0m]: MUTLI / EXEC basics
[[0;32;49mok[0m]: DISCARD
[[0;32;49mok[0m]: Nested MULTI are not allowed
[[0;32;49mok[0m]: MULTI where commands alter argc/argv
[[0;32;49mok[0m]: WATCH inside MULTI is not allowed
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #1
[[0;32;49mok[0m]: EXEC fails if there are errors while queueing commands #2
[[0;32;49mok[0m]: If EXEC aborts, the client MULTI state is cleared
[[0;32;49mok[0m]: EXEC works on WATCHed key not modified
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 1 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified (1 key of 5 watched)
[[0;32;49mok[0m]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty
[[0;32;49mok[0m]: After successful EXEC key is no longer watched
[[0;32;49mok[0m]: After failed EXEC key is no longer watched
[[0;32;49mok[0m]: It is possible to UNWATCH
[[0;32;49mok[0m]: UNWATCH when there is nothing watched works as expected
[[0;32;49mok[0m]: FLUSHALL is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHALL does not touch non affected keys
[[0;32;49mok[0m]: FLUSHDB is able to touch the watched keys
[[0;32;49mok[0m]: FLUSHDB does not touch non affected keys
[[0;32;49mok[0m]: SWAPDB is able to touch the watched keys that exist
[[0;32;49mok[0m]: SWAPDB is able to touch the watched keys that do not exist
[[0;32;49mok[0m]: WATCH is able to remember the DB a key belongs to
[[0;32;49mok[0m]: WATCH will consider touched keys target of EXPIRE
[[0;32;49mok[0m]: FUZZ stresser with data model binary
[[0;32;49mok[0m]: EXPIRE and SET/GETEX EX/PX/EXAT/PXAT option, TTL should not be reset after loadaof
[[0;32;49mok[0m]: EXPIRE relative and absolute propagation to replicas
[[0;32;49mok[0m]: SET command will remove expire
[[0;32;49mok[0m]: SET - use KEEPTTL option, TTL should not be removed
[[0;32;49mok[0m]: LTRIM stress testing - linkedlist
[[0;32;49mok[0m]: WATCH will consider touched expired keys
[[0;32;49mok[0m]: DISCARD should clear the WATCH dirty flag on the client
[[0;32;49mok[0m]: GETRANGE fuzzing
[[0;32;49mok[0m]: Extended SET can detect syntax errors
[[0;32;49mok[0m]: DISCARD should UNWATCH all the keys
[[0;32;49mok[0m]: Extended SET NX option
[[0;32;49mok[0m]: Extended SET XX option
[[0;32;49mok[0m]: Extended SET GET option
[[0;32;49mok[0m]: Extended SET GET option with no previous value
[[0;32;49mok[0m]: Extended SET GET with NX option should result in syntax err
[[0;32;49mok[0m]: Extended SET GET with incorrect type should result in wrong type error
[[0;32;49mok[0m]: Extended SET EX option
[[0;32;49mok[0m]: Extended SET PX option
[[0;32;49mok[0m]: Extended SET EXAT option
[[0;32;49mok[0m]: Extended SET PXAT option
[[0;32;49mok[0m]: Extended SET using multiple options at once
[[0;32;49mok[0m]: GETRANGE with huge ranges, Github issue #1844
[[0;32;49mok[0m]: STRALGO LCS string output with STRINGS option
[[0;32;49mok[0m]: STRALGO LCS len
[[0;32;49mok[0m]: LCS with KEYS option
[[0;32;49mok[0m]: LCS indexes
[[0;32;49mok[0m]: LCS indexes with match len
[[0;32;49mok[0m]: LCS indexes with match len and minimum match len
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (single write command)
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key
[[0;32;49mok[0m]: Old Big Linked list: SORT BY key with limit
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (empty transaction)
[[0;32;49mok[0m]: FUZZ stresser with data model alpha
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (read-only commands)
[[0;32;49mok[0m]: QUIT returns OK
[[0;32;49mok[0m]: Pipelined commands after QUIT must not be executed
[[0;32;49mok[0m]: Pipelined commands after QUIT that exceed read buffer size
[[0;32;49mok[0m]: Old Big Linked list: SORT BY hash field
[[0;32;49mok[0m]: Intset: SORT BY key
[[0;32;49mok[0m]: Intset: SORT BY key with limit
[[0;32;49mok[0m]: Intset: SORT BY hash field
[[0;32;49mok[0m]: MULTI / EXEC is propagated correctly (write command, no effect)
[[0;32;49mok[0m]: DISCARD should not fail during OOM
[8/64 [0;33;49mdone[0m]: unit/type/string (30 seconds)
[1;37;49mTesting unit/acl[0m
[[0;32;49mok[0m]: MULTI and script timeout
[[0;32;49mok[0m]: SET - use KEEPTTL option, TTL should not be removed after loadaof
[[0;32;49mok[0m]: GETEX use of PERSIST option should remove TTL
[[0;32;49mok[0m]: EXEC and script timeout
[[0;32;49mok[0m]: Hash table: SORT BY key
[[0;32;49mok[0m]: Hash table: SORT BY key with limit
[[0;32;49mok[0m]: Hash table: SORT BY hash field
[[0;32;49mok[0m]: FUZZ stresser with data model compr
[9/64 [0;33;49mdone[0m]: unit/quit (7 seconds)
[1;37;49mTesting unit/latency-monitor[0m
[[0;32;49mok[0m]: SCAN regression test for issue #4906
[[0;32;49mok[0m]: MULTI-EXEC body and script timeout
[[0;32;49mok[0m]: MIGRATE cached connections are released after some time
[[0;32;49mok[0m]: just EXEC and script timeout
[[0;32;49mok[0m]: exec with write commands and state change
[10/64 [0;33;49mdone[0m]: unit/scan (33 seconds)
[1;37;49mTesting integration/block-repl[0m
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=0)
[[0;32;49mok[0m]: MASTERAUTH test with binary password
[[0;32;49mok[0m]: intsets implementation stress testing
[[0;32;49mok[0m]: BGSAVE
[[0;32;49mok[0m]: SELECT an out of range DB
[[0;32;49mok[0m]: Consumer group last ID propagation to slave (NOACK=1)
[[0;32;49mok[0m]: GETEX use of PERSIST option should remove TTL after loadaof
[11/64 [0;33;49mdone[0m]: unit/type/set (33 seconds)
[1;37;49mTesting integration/replication[0m
[[0;32;49mok[0m]: GETEX propagate as to replica as PERSIST, DEL, or nothing
[12/64 [0;33;49mdone[0m]: unit/auth (35 seconds)
[1;37;49mTesting integration/replication-2[0m
[13/64 [0;33;49mdone[0m]: unit/expire (26 seconds)
[1;37;49mTesting integration/replication-3[0m
[[0;31;49merr[0m]: Blocking XREAD waiting new data in tests/unit/type/stream.tcl
Expected [lindex  0 0] eq {s2} (context: type eval line 7 cmd {assert {[lindex $res 0 0] eq {s2}}} proc ::test)
[[0;32;49mok[0m]: Blocking XREAD waiting old data
[[0;32;49mok[0m]: Blocking XREAD will not reply with an empty array
[[0;32;49mok[0m]: XREAD: XADD + DEL should not awake client
[[0;32;49mok[0m]: XREAD: XADD + DEL + LPUSH should not awake client
[[0;32;49mok[0m]: Check consistency of different data types after a reload
[[0;32;49mok[0m]: Same dataset digest if saving/reloading as AOF?
[[0;32;49mok[0m]: Connections start with the default user
[[0;32;49mok[0m]: It is possible to create new users
[[0;32;49mok[0m]: New users start disabled
[[0;32;49mok[0m]: Enabling the user allows the login
[[0;32;49mok[0m]: Only the set of correct passwords work
[[0;32;49mok[0m]: It is possible to remove passwords from the set of valid ones
[[0;32;49mok[0m]: Test password hashes can be added
[[0;32;49mok[0m]: Test password hashes validate input
[[0;32;49mok[0m]: ACL GETUSER returns the password hash instead of the actual password
[[0;32;49mok[0m]: Test hashed passwords removal
[[0;32;49mok[0m]: By default users are not able to access any command
[[0;32;49mok[0m]: By default users are not able to access any key
[[0;32;49mok[0m]: It's possible to allow the access of a subset of keys
[[0;32;49mok[0m]: By default users are able to publish to any channel
[[0;32;49mok[0m]: By default users are able to subscribe to any channel
[[0;32;49mok[0m]: By default users are able to subscribe to any pattern
[[0;32;49mok[0m]: It's possible to allow publishing to a subset of channels
[[0;32;49mok[0m]: Validate subset of channels is prefixed with resetchannels flag
[[0;32;49mok[0m]: In transaction queue publish/subscribe/psubscribe to unauthorized channel will fail
[[0;32;49mok[0m]: It's possible to allow subscribing to a subset of channels
[[0;32;49mok[0m]: It's possible to allow subscribing to a subset of channel patterns
[[0;32;49mok[0m]: Subscribers are killed when revoked of channel permission
[[0;32;49mok[0m]: Subscribers are killed when revoked of pattern permission
[[0;32;49mok[0m]: Subscribers are pardoned if literal permissions are retained and/or gaining allchannels
[[0;32;49mok[0m]: Users can be configured to authenticate with any password
[[0;32;49mok[0m]: ACLs can exclude single commands
[[0;32;49mok[0m]: ACLs can include or exclude whole classes of commands
[[0;32;49mok[0m]: ACLs can include single subcommands
[[0;32;49mok[0m]: ACLs set can include subcommands, if already full command exists
[[0;32;49mok[0m]: ACL GETUSER is able to translate back command permissions
[[0;32;49mok[0m]: ACL GETUSER provides reasonable results
[[0;32;49mok[0m]: ACL #5998 regression: memory leaks adding / removing subcommands
[[0;32;49mok[0m]: ACL LOG shows failed command executions at toplevel
[[0;32;49mok[0m]: ACL LOG is able to test similar events
[[0;32;49mok[0m]: ACL LOG is able to log keys access violations and key name
[[0;32;49mok[0m]: ACL LOG is able to log channel access violations and channel name
[[0;32;49mok[0m]: ACL LOG RESET is able to flush the entries in the log
[[0;32;49mok[0m]: ACL LOG can distinguish the transaction context (1)
[[0;32;49mok[0m]: exec with read commands and stale replica state change
[[0;32;49mok[0m]: EXEC with only read commands should not be rejected when OOM
[[0;32;49mok[0m]: ACL LOG can distinguish the transaction context (2)
[[0;32;49mok[0m]: EXEC with at least one use-memory command should fail
[[0;32;49mok[0m]: ACL can log errors in the context of Lua scripting
[[0;32;49mok[0m]: ACL LOG can accept a numerical argument to show less entries
[[0;32;49mok[0m]: Blocking commands ignores the timeout
[[0;32;49mok[0m]: ACL LOG can log failed auth attempts
[[0;32;49mok[0m]: ACL LOG entries are limited to a maximum amount
[[0;32;49mok[0m]: When default user is off, new connections are not authenticated
[[0;32;49mok[0m]: When default user has no command permission, hello command still works for other users
[[0;32;49mok[0m]: ACL HELP should not have unexpected options
[[0;32;49mok[0m]: Delete a user that the client doesn't use
[[0;32;49mok[0m]: Delete a user that the client is using
[[0;32;49mok[0m]: MULTI propagation of PUBLISH
[[0;32;49mok[0m]: EXPIRES after a reload (snapshot + append only file rewrite)
[[0;32;49mok[0m]: MULTI propagation of SCRIPT LOAD
[[0;32;49mok[0m]: MULTI propagation of SCRIPT LOAD
[[0;32;49mok[0m]: MIGRATE is able to migrate a key between two instances
[[0;32;49mok[0m]: MULTI propagation of XREADGROUP
[[0;32;49mok[0m]: ZDIFF fuzzing - skiplist
[[0;32;49mok[0m]: Basic ZPOP with a single key - skiplist
[[0;32;49mok[0m]: ZPOP with count - skiplist
[[0;32;49mok[0m]: BZPOP with a single existing sorted set - skiplist
[[0;32;49mok[0m]: BZPOP with multiple existing sorted sets - skiplist
[[0;32;49mok[0m]: BZPOP second sorted set has members - skiplist
[[0;32;49mok[0m]: ZINTERSTORE regression with two sets, intset+hashtable
[[0;32;49mok[0m]: ZUNIONSTORE regression, should not create NaN in scores
[[0;32;49mok[0m]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets
[[0;32;49mok[0m]: ZUNIONSTORE result is sorted
[[0;32;49mok[0m]: ZUNIONSTORE/ZINTERSTORE/ZDIFFSTORE error if using WITHSCORES 
[[0;32;49mok[0m]: ZMSCORE retrieve
[[0;32;49mok[0m]: ZMSCORE retrieve from empty set
[[0;32;49mok[0m]: ZMSCORE retrieve with missing member
[[0;32;49mok[0m]: ZMSCORE retrieve single member
[14/64 [0;33;49mdone[0m]: unit/multi (21 seconds)
[1;37;49mTesting integration/replication-4[0m
[[0;32;49mok[0m]: ZMSCORE retrieve requires one or more members
[[0;32;49mok[0m]: ZSET commands don't accept the empty strings as valid score
[[0;32;49mok[0m]: ZSCORE - ziplist
[[0;32;49mok[0m]: ZMSCORE - ziplist
[[0;32;49mok[0m]: Empty stream with no lastid can be rewrite into AOF correctly
[[0;32;49mok[0m]: Test latency events logging
[[0;32;49mok[0m]: LATENCY HISTORY output is ok
[[0;32;49mok[0m]: LATENCY LATEST output is ok
[[0;32;49mok[0m]: LATENCY HISTORY / RESET with wrong event name is fine
[[0;32;49mok[0m]: LATENCY DOCTOR produces some output
[[0;32;49mok[0m]: LATENCY RESET is able to reset events
[[0;32;49mok[0m]: ZSCORE after a DEBUG RELOAD - ziplist
[[0;32;49mok[0m]: ZSET sorting stresser - ziplist
[15/64 [0;33;49mdone[0m]: unit/type/stream-cgroups (38 seconds)
[1;37;49mTesting integration/replication-psync[0m
[[0;32;49mok[0m]: Big Hash table: SORT BY key
[[0;32;49mok[0m]: Big Hash table: SORT BY key with limit
[[0;32;49mok[0m]: Big Hash table: SORT BY hash field
[[0;32;49mok[0m]: EXPIRES after AOF reload (without rewrite)
[[0;32;49mok[0m]: SORT GET #
[[0;32;49mok[0m]: SORT GET <const>
[[0;32;49mok[0m]: SORT GET (key and hash) with sanity check
[[0;32;49mok[0m]: SORT BY key STORE
[[0;32;49mok[0m]: SORT BY hash field STORE
[[0;32;49mok[0m]: SORT extracts STORE correctly
[[0;32;49mok[0m]: SORT extracts multiple STORE correctly
[[0;32;49mok[0m]: SORT DESC
[[0;32;49mok[0m]: SORT ALPHA against integer encoded strings
[[0;32;49mok[0m]: SORT sorted set
[[0;32;49mok[0m]: SORT sorted set BY nosort should retain ordering
[[0;32;49mok[0m]: SORT sorted set BY nosort + LIMIT
[[0;32;49mok[0m]: SORT sorted set BY nosort works as expected from scripts
[[0;32;49mok[0m]: SORT sorted set: +inf and -inf handling
[[0;32;49mok[0m]: SORT regression for issue #19, sorting floats
[[0;32;49mok[0m]: SORT with STORE returns zero if result is empty (github issue 224)
[[0;32;49mok[0m]: SORT with STORE does not create empty lists (github issue 224)
[[0;32;49mok[0m]: SORT with STORE removes key if result is empty (github issue 227)
[[0;32;49mok[0m]: SORT with BY <constant> and STORE should still order output
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (1)
[[0;32;49mok[0m]: SORT will complain with numerical sorting and bad doubles (2)
[[0;32;49mok[0m]: SORT BY sub-sorts lexicographically if score is the same
[[0;32;49mok[0m]: SORT GET with pattern ending with just -> does not get hash field
[[0;32;49mok[0m]: SORT by nosort retains native order for lists
[[0;32;49mok[0m]: SORT by nosort plus store retains native order for lists
[[0;32;49mok[0m]: SORT by nosort with limit returns based on original list order
[[0;32;49mok[0m]: SORT speed, 100 element list BY key, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY hash field, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list directly, 100 times
[[0;32;49mok[0m]: SORT speed, 100 element list BY <const>, 100 times
[[0;32;49mok[0m]: PIPELINING stresser (also a regression for the old epoll bug)
[[0;32;49mok[0m]: APPEND basics
[[0;32;49mok[0m]: APPEND basics, integer encoded values
[16/64 [0;33;49mdone[0m]: unit/sort (37 seconds)
[1;37;49mTesting integration/aof[0m
[[0;32;49mok[0m]: APPEND fuzzing
[[0;32;49mok[0m]: FLUSHDB
[[0;32;49mok[0m]: Perform a final SAVE to leave a clean DB on disk
[[0;32;49mok[0m]: RESET clears client state
[[0;32;49mok[0m]: RESET clears MONITOR state
[[0;32;49mok[0m]: RESET clears and discards MULTI state
[[0;32;49mok[0m]: RESET clears Pub/Sub state
[[0;32;49mok[0m]: RESET clears authenticated state
[[0;32;49mok[0m]: Slave enters handshake
[[0;32;49mok[0m]: default: load from include file, can access any channels
[[0;32;49mok[0m]: default: with config acl-pubsub-default allchannels after reset, can access any channels
[[0;32;49mok[0m]: default: with config acl-pubsub-default resetchannels after reset, can not access any channels
[[0;32;49mok[0m]: Alice: can execute all command
[[0;32;49mok[0m]: Bob: just execute @set and acl command
[[0;31;49merr[0m]: ACL load and save in tests/unit/acl.tcl
Expected 'error reading "sock8000f00e0": software caused connection abort' to match '*I/O error*' (context: type eval line 8 cmd {assert_match {*I/O error*} $e} proc ::test)
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted
[[0;32;49mok[0m]: No write if min-slaves-to-write is < attached slaves
[[0;32;49mok[0m]: If min-slaves-to-write is honored, write is accepted (again)
[[0;32;49mok[0m]: MIGRATE is able to copy a key between two instances
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;32;49mok[0m]: First server should have role slave after SLAVEOF
[[0;31;49mexception[0m]: Executing test client: I/O error reading reply.
I/O error reading reply
    while executing
"[srv $level "client"] {*}$args"
    (procedure "r" line 7)
    invoked from within
"r AUTH alice alice"
    ("uplevel" body line 2)
    invoked from within
"uplevel 1 $code"
    (procedure "test" line 51)
    invoked from within
"test {ACL load and save with restricted channels} {
        r AUTH alice alice
        r ACL setuser harry on nopass resetchannels &test +@all ~*
    ..."
    ("uplevel" body line 67)
    invoked from within
"uplevel 1 $code "
    (procedure "start_server" line 3)
    invoked from within
"start_server [list overrides [list "dir" $server_path "aclfile" "user.acl"]] {
    # user alice on allcommands allkeys >alice
    # user bob on -@all ..."
    (file "tests/unit/acl.tcl" line 485)
    invoked from within
"source $path"
    (procedure "execute_test_file" line 4)
    invoked from within
"execute_test_file $data"
    (procedure "test_client_main" line 10)
    invoked from within
"test_client_main $::test_server_port "
Killing still running Redis server 29373
Killing still running Redis server 29391
Killing still running Redis server 29402
Killing still running Redis server 29406
Killing still running Redis server 29409
Killing still running Redis server 29677
Killing still running Redis server 29739
Killing still running Redis server 29746
Killing still running Redis server 29751
Killing still running Redis server 29764
Killing still running Redis server 29778
Killing still running Redis server 29845
Killing still running Redis server 29854
Killing still running Redis server 29855
Killing still running Redis server 29858
Killing still running Redis server 29871
make[1]: Leaving directory '/cygdrive/d/code/redis-6.2.2/src'
